from langchain_core.messages import AIMessage
from configuration import state
from prompts import graph_and_exploitation_inference_prompt
from .node_utils import OPEN_AI_KEY, BOFFA_KEY, OPENROUTER_URL, DEEPSEEK_STRING
from openai import BadRequestError 
import logging
from pydantic import BaseModel, ValidationError
import instructor
from openai import OpenAI

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class StructuredOutput(BaseModel):
    reasoning: str 
    inferred_attack_graph: dict 
    honeypot_exploitation: list


def get_last_epoch_fields(last_epoch):
    last_exploitation = {}
    last_attack_graph = {}
    if last_epoch:
        last_epoch = last_epoch[0].value
        last_exploitation = last_epoch.get('honeypots_exploitation', {})
        last_attack_graph = last_epoch.get('inferred_attack_graph', {})

    return last_exploitation, last_attack_graph


async def graph_and_exploitation_inference(state: state.HoneypotStateReact, config):
    """
    Infers/Update the attack graph from event summaries
    """
    logger.info("Inference Agent")
    episodic_memory = config.get("configurable", {}).get("store")
    model_config = config.get("configurable", {}).get("model_config", "large:4.1")
    epoch_num = config.get("configurable", {}).get("epoch_num")


    last_epoch = episodic_memory.get_recent_iterations(limit=1)
    last_exploitation, last_attack_graph = get_last_epoch_fields(last_epoch)
    
    
    prompt = graph_and_exploitation_inference_prompt.USER_PROMPT.substitute(
        security_events_summary=state.security_events_summary,
        available_honeypots=state.honeypot_config,
        previous_exploitation=last_exploitation,
        previous_attack_graph=last_attack_graph,
        ) 

    message = ""
    size, version = model_config.split(':')
    model_name = f"gpt-{version}"
    logger.info(f"Using: {model_name}")


    try:
        messages = [
            {"role" : "system", "content": graph_and_exploitation_inference_prompt.SYSTEM_PROMPT},
            {"role" : "user", "content" : prompt}
        ]
        response = StructuredOutput(reasoning="", inferred_attack_graph={}, honeypot_exploitation=[])

        if version == '5':
            valid_json = False
            while(not valid_json):
                logger.info(f"Using gpt5 low effort")
                schema = StructuredOutput.model_json_schema()
                client = OpenAI()
                raw = client.responses.create( # type: ignore
                    model="gpt-5",
                    input=f"{prompt}\n\nReturn valid JSON matching this schema:\n{schema}",
                    reasoning={"effort":"low"},
                )
                content = raw.output_text
                try:
                    response = StructuredOutput.model_validate_json(content)
                    valid_json = True
                except ValidationError as e:
                    logger.error(f"Schema validation failed: \n{e}")
                    response = StructuredOutput(reasoning="", inferred_attack_graph={}, honeypot_exploitation=[])

        elif version == "4.1":
            agent = instructor.from_openai(OpenAI(api_key=OPEN_AI_KEY))
            response: StructuredOutput = agent.chat.completions.create(
                model=model_name,
                response_model=StructuredOutput,
                messages=messages # type: ignore
            )

        message += f"Reasoning: {str(response.reasoning)}" + "\n"
        message += f"Inferred Attack Graph: {str(response.inferred_attack_graph)}" + "\n"
        message += f"Honeypot Exploitation: {str(response.honeypot_exploitation)}"
        message = AIMessage(content=message)
        return {
            "messages": [message],
            "inferred_attack_graph":response.inferred_attack_graph, 
            "reasoning_inference":response.reasoning, 
            "honeypots_exploitation":response.honeypot_exploitation
        }


    except BadRequestError as e:
        logger.error(f"Error: {e}")
    except Exception as e:
        logger.error(f"Error parsing json in attack graph inference:\n{e}")
    return {
        "messages":[message]
        }


