from langchain_core.messages import AIMessage
from configuration import state
from prompts import graph_and_exploitation_inference_prompt
from .node_utils import OPEN_AI_KEY
from openai import BadRequestError 
import logging
from pydantic import BaseModel, ValidationError, Field
import instructor
from openai import OpenAI

from typing import Dict, List, Any, Tuple
import copy
import ipaddress

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class PhaseDelta(BaseModel):
    phase: str
    evidence_quotes: List[str]

class EdgeUpdate(BaseModel):
    from_: str = Field(..., alias="from")
    to: str
    new_phases: List[PhaseDelta]

class HoneypotExploitationUpdate(BaseModel):
    ip: str
    service: str
    level_prev: int
    level_new: int
    evidence_quotes: List[str]

class DeltaOutput(BaseModel):
    reasoning: str
    edge_updates: List[EdgeUpdate] = []
    honeypot_exploitation_updates: List[HoneypotExploitationUpdate] = []


PHASE_RANK = {
  "scan":0,
  "initial-access/rce":1,
  "data-exfil-user":2,
  "privilege-escalation":3,
  "data-exfil-root":4
}

EXPLOITATION_FROM_PHASE = {
  "scan": 25,
  "initial-access/rce": 50,
  "data-exfil-user": 75,
  "privilege-escalation": 100,
  "data-exfil-root": 100
}

def ip_in_subnet(ip: str, subnet: str) -> bool:
    try:
        return ipaddress.ip_address(ip) in ipaddress.ip_network(subnet)
    except Exception:
        return False

def find_edge(edges: List[Dict[str,Any]], attacker: str, honeypot: str) -> Tuple[int, Dict[str,Any] | None]:
    for i, e in enumerate(edges):
        if e.get("from") == attacker and e.get("to") == honeypot:
            return i, e
    return -1, None

def validate_phase_name(phase: str) -> bool:
    return phase in PHASE_RANK

def merge_deltas_into_graph(prev_graph: Dict[str,Any],
                            prev_exploitation: List[Dict[str,Any]],
                            available_honeypots: List[Dict[str,Any]],
                            deltas: DeltaOutput,
                            ) -> Dict[str,Any]:
    # deep copy to avoid mutating inputs on failure
    graph = copy.deepcopy(prev_graph)
    edges = graph.get("edges", [])
    interesting = { (n["ip"], n["service"]) for n in graph.get("interesting", []) }
    reasoning_lines = []

    # Build quick lookup for honeypot config and exploitation
    honeypot_services = { h["ip"]: h["service"] for h in available_honeypots }
    exploit_map = { h["ip"]: copy.deepcopy(h) for h in prev_exploitation }  # keyed by ip

    # If no deltas -> return prev unchanged
    if not deltas.edge_updates and not deltas.honeypot_exploitation_updates:
        rolled = []
    # Build quick lookup for honeypot config (you already have available_honeypots)
        honeypot_services = { h["ip"]: h["service"] for h in available_honeypots }
        for h in prev_exploitation:
            ip = h["ip"]
            service = h.get("service", honeypot_services.get(ip))
            # roll level_prev forward to last level_new
            level_prev = h.get("level_new", h.get("level_prev", 0))
            rolled.append({
                "ip": ip,
                "service": service,
                "level_prev": level_prev,
                "level_new": level_prev,
                "changed": False,
                "evidence_quotes": []
            })

        return {
            "reasoning": "no updates in delta; returning previous graph unchanged",
            "inferred_attack_graph": prev_graph,
            "honeypot_exploitation": rolled
        }

    # 1) Apply edge updates
    for eu in deltas.edge_updates:
        att = eu.from_
        hp = eu.to
        # SERVICE & IP GUARDS
        if not ip_in_subnet(att, "192.168.100.0/24"):
            raise ValueError(f"attacker {att} outside attacker subnet")
        if not ip_in_subnet(hp, "172.20.0.0/24"):
            raise ValueError(f"honeypot {hp} outside honeypots subnet")
        if hp not in honeypot_services:
            raise ValueError(f"honeypot {hp} not in available_honeypots")

        idx, existing_edge = find_edge(edges, att, hp)
        created_new_edge = False
        if existing_edge is None:
            # create new edge skeleton
            created_new_edge = True
            existing_edge = {
                "from": att,
                "to": hp,
                "phases": [],
                "current_phase": None,
                "vector": None
            }
            edges.append(existing_edge)
            idx = len(edges) - 1
        
        added_phases = []
        for pd in eu.new_phases:
            if not validate_phase_name(pd.phase):
                raise ValueError(f"unknown phase {pd.phase}")
            # Check evidence quotes exist
            if not pd.evidence_quotes or any(not q or not isinstance(q, str) for q in pd.evidence_quotes):
                raise ValueError("each added phase must include >=1 exact evidence_quotes")
            # If phase already present on edge, skip
            already = False
            for existing_phase in existing_edge["phases"]:
                if existing_phase["phase"] == pd.phase:
                    already = True
                    break
            if already:
                continue
            # Add phase object
            phase_obj = {
                "phase": pd.phase,
                "evidence_quotes": pd.evidence_quotes,
            }
            existing_edge["phases"].append(phase_obj)
            added_phases.append(pd.phase)

        if added_phases:
            # Sort/normalize phases by rank for predictable output
            existing_edge["phases"].sort(key=lambda p: PHASE_RANK.get(p["phase"], 0))
            # update current_phase / vector to the highest rank
            highest = max(existing_edge["phases"], key=lambda p: PHASE_RANK[p["phase"]])
            existing_edge["current_phase"] = highest["phase"]
            existing_edge["vector"] = highest["phase"]
            # Append reasoning
            reasoning_lines.append(f"{att} -> {hp}: added phases {added_phases} with quotes { [p['evidence_quotes'][0] for p in existing_edge['phases'] if p['phase'] in added_phases] }")
        else:
            reasoning_lines.append(f"{att} -> {hp}: no new phases to add (skipped)")

    # 2) Recompute exploitation per honeypot deterministically as MAX over edges
    # Build per-honeypot edge list
    per_hp_edges = {}
    for e in edges:
        per_hp_edges.setdefault(e["to"], []).append(e)

    honeypot_updates_result = []
    for hp_ip, service in honeypot_services.items():
        prev_entry = exploit_map.get(hp_ip, {"ip": hp_ip, "service": service, "level_prev": 0, "level_new": 0, "changed": False, "evidence_quotes": []})
        level_prev = prev_entry.get("level_new", prev_entry.get("level_prev", 0))

        # compute max over edges
        max_level = level_prev
        evidence_for_level = []
        for e in per_hp_edges.get(hp_ip, []):
            # highest phase of edge -> its exploitation mapping
            if not e.get("phases"):
                continue
            highest_phase = max(e["phases"], key=lambda p: PHASE_RANK[p["phase"]])
            lvl = EXPLOITATION_FROM_PHASE.get(highest_phase["phase"], 0)
            if lvl > max_level:
                max_level = lvl
                # minimal evidence: take the quote from the newly added phase(s) if present; fallback to highest_phase quote
                evidence_for_level = highest_phase.get("evidence_quotes", [])[:1]
        # enforce monotonicity
        if max_level < level_prev:
            max_level = level_prev

        changed = (max_level != level_prev)
        if changed:
            # If level_new >=66 -> ensure honeypot in interesting set
            if max_level >= 66:
                interesting.add((hp_ip, service))
            honeypot_updates_result.append({
                "ip": hp_ip,
                "service": service,
                "level_prev": level_prev,
                "level_new": max_level,
                "evidence_quotes": evidence_for_level
            })

    # Build full, rolled-forward state for all honeypots
    full_state = []
    for hp_ip, service in honeypot_services.items():
        # start from previous baseline (take prev level from the previous epoch, if present)
        prev_entry = exploit_map.get(hp_ip, {
            "ip": hp_ip, "service": service,
            "level_prev": 0, "level_new": 0,
            "changed": False, "evidence_quotes": []
        })

        # previous level must reflect the previous epoch's final level (if available)
        level_prev = prev_entry.get("level_new", prev_entry.get("level_prev", 0))

        # determine proposed new level as max over edges (do not reduce below previous)
        level_new = level_prev
        for e in per_hp_edges.get(hp_ip, []):
            if e.get("phases"):
                highest_phase = max(e["phases"], key=lambda p: PHASE_RANK[p["phase"]])
                lvl = EXPLOITATION_FROM_PHASE.get(highest_phase["phase"], 0)
                if lvl > level_new:
                    level_new = lvl

        # enforce monotonicity (should already hold, but be explicit)
        if level_new <= level_prev:
            level_new = level_prev

        changed = (level_new != level_prev)

        # try to attach evidence if we recorded an update for this honeypot earlier
        evidence = []
        for upd in honeypot_updates_result:
            if upd["ip"] == hp_ip:
                evidence = upd.get("evidence_quotes", [])
                break

        full_state.append({
            "ip": hp_ip,
            "service": service,
            "level_prev": level_prev,
            "level_new": level_new,
            "changed": changed,
            "evidence_quotes": evidence
        })


    # Update graph object fields and interesting list
    graph["edges"] = edges
    graph["interesting"] = [{"ip": ip, "service": svc} for ip, svc in sorted(list(interesting))]
    # final output
    return {
        "reasoning": "; ".join(reasoning_lines),
        "inferred_attack_graph": graph,
        "honeypot_exploitation": full_state
    }

def get_last_epoch_fields(last_epoch):
    last_exploitation = []
    last_attack_graph = {}
    if last_epoch:
        last_epoch = last_epoch[0].value
        last_exploitation = last_epoch.get('honeypots_exploitation', [])
        last_attack_graph = last_epoch.get('inferred_attack_graph', {})

    return last_exploitation, last_attack_graph

async def graph_and_exploitation_inference(state: state.HoneypotStateReact, config):
    """
    Infers/Update the attack graph from event summaries
    """
    logger.info("Inference Agent")
    episodic_memory = config.get("configurable", {}).get("store")
    model_config = config.get("configurable", {}).get("model_config", "large:4.1")
    epoch_num = config.get("configurable", {}).get("epoch_num")


    last_epoch = episodic_memory.get_recent_iterations(limit=1)
    last_exploitation, last_attack_graph = get_last_epoch_fields(last_epoch)
    
    if not last_attack_graph or "edges" not in last_attack_graph:
        logger.info("Initializing first-epoch attack graph baseline")
        last_attack_graph = {"edges": [], "interesting": []}

    if not isinstance(last_exploitation, list) or len(last_exploitation) == 0:
        logger.info("Initializing first-epoch honeypot exploitation baseline")
        last_exploitation = [
            {
                "ip": h["ip"],
                "service": h["service"],
                "level_prev": 0,
                "level_new": 0,
                "changed": False,
                "evidence_quotes": []
            }
            for h in state.honeypot_config
        ]

    message = ""
    size, version = model_config.split(':')
    model_name = f"gpt-{version}"
    logger.info(f"Using: {model_name}")


    try:
        messages = [
            {"role" : "system", "content": graph_and_exploitation_inference_prompt.SYSTEM_PROMPT},
            {"role" : "user", "content" : graph_and_exploitation_inference_prompt.USER_PROMPT.substitute(
                security_events_summary=state.security_events_summary,
                available_honeypots=state.honeypot_config,
                previous_exploitation=last_exploitation,
                previous_attack_graph=last_attack_graph,
            )}
        ]
        response = DeltaOutput(reasoning="", edge_updates=[], honeypot_exploitation_updates=[])

        
        if version == "4.1":
            agent = instructor.from_openai(OpenAI(api_key=OPEN_AI_KEY))
            response: DeltaOutput = agent.chat.completions.create(
                model=model_name,
                response_model=DeltaOutput,
                temperature=0.3,
                messages=messages # type: ignore
            )
            logger.info(f"Response: {response}")
            merged = merge_deltas_into_graph(
                prev_graph=last_attack_graph,
                prev_exploitation=last_exploitation,
                available_honeypots=state.honeypot_config,
                deltas=response,
            )
            message += f"Reasoning: {str(merged['reasoning'])}" + "\n"
            message += f"Inferred Attack Graph: {str(merged['inferred_attack_graph'])}" + "\n"
            message += f"Honeypot Exploitation: {str(merged['honeypot_exploitation'])}"
            message = AIMessage(content=message)
            return {
                "messages": [message],
                "inferred_attack_graph": merged["inferred_attack_graph"], 
                "reasoning_inference": merged["reasoning"], 
                "honeypots_exploitation": merged["honeypot_exploitation"]
            }


    except BadRequestError as e:
        logger.error(f"Error: {e}")
    except Exception as e:
        logger.error(f"Error parsing json in attack graph inference:\n{e}")
    return {
        "messages":[message]
        }


