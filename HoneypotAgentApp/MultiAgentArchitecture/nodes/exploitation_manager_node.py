from configuration import state
from prompts import exploitation_plan_prompt
from .node_utils import OPEN_AI_KEY
from openai import BadRequestError
import logging
from pydantic import BaseModel
import instructor
from openai import OpenAI
from typing import List, Dict

class StructuredOutput(BaseModel):
    reasoning: str
    selected_honeypot: dict
    why_not_expose: List[Dict]
    plan: dict
    lockdown: bool

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

async def exploitation_manager(state: state.HoneypotStateReact, config):
    """
    Decides which honeypot(s) to expose next based on current attack graph
    """
    logger.info("Exploitation Agent")

    episodic_memory = config.get("configurable", {}).get("store")
    last_epochs = episodic_memory.get_recent_iterations(limit=10)
    previously_exposed = []
    if last_epochs:
        for epoch in last_epochs:
            epoch = epoch.value
            container = epoch.get('currently_exposed', '')
            if container:
                previously_exposed.append(container.get('service', ''))
    
    previously_exposed = set(previously_exposed)
    prompt = exploitation_plan_prompt.EXPLOITATION_PLAN_PROMPT.substitute(
        available_honeypots=state.honeypot_config,
        firewall_config=state.firewall_config,
        honeypots_exploitations=state.honeypots_exploitation,
        inferred_attack_graph=state.inferred_attack_graph,
        memory_context=state.memory_context,
        exposed_honeypots=previously_exposed

    )

    #logger.info(f"Previously exposed: {previously_exposed}")
    
    try:
        messages = {"role":"system", "content": prompt}
        agent = instructor.from_openai(OpenAI(api_key=OPEN_AI_KEY))
        response = agent.chat.completions.create(
            model='gpt-4.1',
            response_model=StructuredOutput,
            messages=[messages]
        )
        message = ""
        message += f"Reasoning: {str(response.reasoning)}" + "\n"
        message += f"Selected Honeypot: {str(response.selected_honeypot)}" + "\n"
        message += f"Why not expose: {str(response.why_not_expose)}" + "\n"
        message += f"Plan: {str(response.plan)}" + "\n"
        message += f"{str(response.lockdown)}"
        return {
            "messages":state.messages + [message],
            "exploitation_strategy": response.plan,
            "reasoning_exploitation": response.reasoning,
            "currently_exposed":response.selected_honeypot,
            "lockdown_status":response.lockdown
            }
    except BadRequestError as e:
        logger.error(f"Error: {e}")
    except Exception as e:
        logger.error(f"Error during json parsing of response in Exploitation Manager\n{e}")

    return {
        "messages":state.messages + [message],
        }
    
