import subprocess
import threading
import sys
sys.stdout.reconfigure(line_buffering=True)

def stream_output(process, prefix=""):
    """Stream output from process in real-time"""
    for line in iter(process.stdout.readline, ''):
        if line:  # Only print non-empty lines
            print(f"{prefix}{line.strip()}")
    process.stdout.close()

def stream_error(process, prefix="ERROR: "):
    """Stream error from process in real-time"""
    for line in iter(process.stderr.readline, ''):
        if line:  # Only print non-empty lines
            print(f"{prefix}{line.strip()}")
    process.stderr.close()



def execute_docker_exploit():
    """Function to execute the Docker exploit"""
    try:
        # Replace this with your actual script that triggers the connection
        print("[*] Executing Docker exploit...")

        process = subprocess.Popen(
            ["python3", "-u", "/home/c0ff3k1ll3r/Desktop/Thesis/AI_Agent_for_honeypot_operations/Benchmark/vulnerableMachines/multi_step_machine/docker/unauthorized-rce/scripts/exploit.py"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            bufsize=1,
            text=True
            )
        
        # Create threads to stream output in real-time
        stdout_thread = threading.Thread(target=stream_output, args=(process, "DOCKER: "))
        stderr_thread = threading.Thread(target=stream_error, args=(process, "DOCKER ERROR: "))
        
        # Start the threads
        stdout_thread.daemon = True
        stderr_thread.daemon = True
        stdout_thread.start()
        stderr_thread.start()
        
        # Wait for the process to complete
        return_code = process.wait()
        
        # Wait for output threads to finish
        stdout_thread.join()
        stderr_thread.join()
        print(f"[*] Docker exploit completed with return code: {return_code}")
        return return_code
    except Exception as e:
        print(f"[!] Error executing Docker exploit: {e}")
        return 1

    

def execute_struts_exploit():
    """Function to execute the Struts exploit"""
    try:
        # Replace this with your actual script that triggers the connection
        print("[*] Executing Struts exploit...")

        process = subprocess.Popen(
            ["python3", "-u", "/home/c0ff3k1ll3r/Desktop/Thesis/AI_Agent_for_honeypot_operations/Benchmark/vulnerableMachines/multi_step_machine/struts2/s2-057/scripts/exploit.py"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            bufsize=0,
            text=True
        )
        
        # Create threads to stream output in real-time
        stdout_thread = threading.Thread(target=stream_output, args=(process, "STRUTS: "))
        stderr_thread = threading.Thread(target=stream_error, args=(process, "STRUTS ERROR: "))
        
        # Start the threads
        stdout_thread.daemon = True
        stderr_thread.daemon = True
        stdout_thread.start()
        stderr_thread.start()
        
        # Wait for the process to complete
        return_code = process.wait()
        
        # Wait for output threads to finish
        stdout_thread.join()
        stderr_thread.join()
        
        print(f"[*] Struts exploit completed with return code: {return_code}")
        return return_code
        
    except Exception as e:
        print(f"[!] Error executing Struts exploit: {e}")
        return 1



def main():
    """Main function to execute the exploits"""
    print("[*] Starting exploit execution...")

    # Execute Docker exploit
    result_code = execute_docker_exploit()

    print("=" * 50)
    if result_code == 0:
        print("[*] First exploit executed.")
    else:
        print("[!] First exploit failed.")
        return result_code
    print("=" * 50)
    # Execute Struts exploit
    result_code = execute_struts_exploit()

    print("=" * 50)
    if result_code == 0:
        print("Second exploit executed.")
        print("=" * 50)
        print("\n[*] Exploit successful!")
    else:
        print("[!] Second exploit failed.")
        return result_code
    
    return 0

if __name__ == "__main__":
    main()